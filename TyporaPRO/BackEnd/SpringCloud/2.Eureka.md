

# 一、提供者与消费者

在服务调用关系中，会有两个不同的角色：

**服务提供者**：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）

**服务消费者**：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）

![image-20210713214404481](image/image-20210713214404481.png)



但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。

如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？

- 对于A调用B的业务而言：A是服务消费者，B是服务提供者
- 对于B调用C的业务而言：B是服务消费者，C是服务提供者

因此，服务B既可以是服务提供者，也可以是服务消费者。

# 二、Eureka的结构和作用

## 1、Eureka的两大组件

回到官网的图片可以看出在这个体系中，有2个主体：`Eureka Server`和`Eureka Client`

### Eureka Server

- `提供服务注册`：各个微服务启动时，会通过Eureka Client向Eureka Server进行注册自己的信息（例如服务信息和网络信息），Eureka Server会存储该服务的信息。

- `提供服务信息提供`：服务消费者在调用服务时，本地Eureka Client没有的情况下，会到Eureka Server拉取信息。

- `提供服务管理`：通过Eureka Client的`Cancel`、`心跳监控`、`renew`等方式来维护该服务提供的信息以确保该服务可用以及服务的更新。

- `信息同步`：每个`Eureka Server`同时也是`Eureka Client`，多个Eureka Server之间通过`P2P`复制的方式完成服务注册表的同步。`同步时，被同步信息不会同步出去`。也就是说有3个`Eureka Server`，Server1有新的服务信息时，同步到Server2后，Server2和Server3同步时，Server2不会把从Server1那里同步到的信息同步给Server3，只能由Server1自己同步给Server3。

每个可用区有一个Eureka集群，并且每个可用区至少有一个eureka服务器来处理区内故障。为了实现高可用，一般一个可用区中由三个Eureka Server组成。

### Eureka Client

- Eureka Client是一个Java客户端，用于简化与Eureka Server的交互。并且管理当前微服务，同时为当前的微服务提供服务提供者信息。

- Eureka Client会拉取、更新和缓存Eureka Server中的信息。即使所有的Eureka Server节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者。

- Eureka Client在微服务启动后，会周期性地向Eureka Server发送心跳（默认周期为`30`秒）以续约自己的信息。如果Eureka Server在一定时间内没有接收到某个微服务节点的心跳，Eureka Server将会注销该微服务节点（默认`90`秒）。

- Eureka Client包含服务提供者`Applicaton Service`和服务消费者`Application Client`

- `Applicaton Service`：服务提供者，提供服务给别个调用。

- `Application Client`：服务消费者，调用别个提供的服务。

往往大多数服务本身既是服务提供者，也是服务消费者。

### 其它动作

#### Register：服务注册

当Eureka客户端向Eureka Server注册时，它提供自身的元数据，比如IP地址、端口，运行状况指示符URL，主页等。

#### Renew：服务续约

Eureka Client会每隔30秒发送一次心跳来续约。 通过续约来告知Eureka Server该Eureka客户仍然存在，没有出现问题。 正常情况下，如果Eureka Server在90秒没有收到Eureka客户的续约，它会将实例从其注册表中删除。 建议不要更改续约间隔。

#### Fetch Registries：获取注册列表信息

Eureka客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与Eureka客户端的缓存信息不同， Eureka客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，Eureka客户端则会重新获取整个注册表信息。 Eureka服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。Eureka客户端和Eureka 服务器可以使用JSON / XML格式进行通讯。在默认的情况下Eureka客户端使用压缩JSON格式来获取注册列表的信息。

#### Cancel：服务下线

Eureka客户端在程序关闭时向Eureka服务器发送取消请求。 发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：

```java
DiscoveryManager.getInstance().shutdownComponent()；
```



#### Eviction 服务剔除

`在默认的情况下，当Eureka客户端连续90秒没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除，即服务剔除`。

这些问题都需要利用`SpringCloud`中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：

![image-20210713220104956](image/image-20210713220104956.png)



## 2、RestTemplate问题

当我们直接使用RestTemplate去调用其他服务时会碰到以下问题：

![image-20220528195957293](image/image-20220528195957293.png)

如果用户信息的服务有多个该怎么办，例如：

![image-20220528200054539](image/image-20220528200054539.png)

## 3、解决问题

### OrderService如何得知UserService实例地址？

获取地址信息的流程如下：

- `UserService`服务实例启动后，将自己的信息注册到`UserService`（`Eureka`服务端）。这个叫服务注册
- `UserService`保存服务名称到服务实例地址列表的映射关系
- `OrderService`根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取



### OrderService如何从多个UserService实例中选择具体的实例？

- `OrderService`从实例列表中利用`负载均衡`算法选中一个实例地址，向该实例地址发起远程调用



### OrderService如何得知某个UserService实例是否依然健康，是不是已经宕机？

- `UserService`会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳
- 当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除
- `OrderService`拉取服务时，就能将故障实例排除了



> 注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端

# 三、Eureka的单机环境组建

## 1、新建模块

新建EurekaServer：`AxEurekaServer(9090)`

## 2、引入eureka依赖

引入SpringCloud为eureka提供的starter依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
```

## 3、启动类

给eureka-server服务编写一个启动类，一定要添加一个`@EnableEurekaServer`注解，开启eureka的注册中心功能：

```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
```

==在项目启动类上使用@EnableEurekaServer，可以将项目作为SpringCloud中的注册中心。==激活Eureka服务器相关配置EurekaServerAutoConfiguration的注释，可以将@EnableEurekaServer 这个注解看作是一个开关，开启时，会激活相关配置，会作为注册中心。同时，他又引入了EurekaServerMarkerConfiguration类。

## 4、新建yml文件

```yaml
server:
  port: 9090
spring:
  application:
    name: AxEurekaServer
eureka:
  instance:
    hostname: eureka9090.com
  client:
    register-with-eureka: false #表示不向注册中心注册自己
    #    fetch-registry: false #自己就是服务注册中心，不需要去检索服务
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
      # 互相守望
#      defaultZone: http://eureka9091.com:9091/eureka/
  server:
    enable-self-preservation: true #禁用自我保护
    eviction-interval-timer-in-ms: 3000 #修改检查失效服务的时间（ms）
```



## 5、启动测试

在地址栏输入http:// eureka9090.com:9090/

出现spring Eureka即配置成功。

## 6、注册User模块

将`AaUserService（8800）`注册到`AxEurekaServer (9090)`

### 引入依赖

在`userservice`的pom文件中，引入下面的`eureka-client`依赖：

```xml
<!--eureka客户端依赖-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

### 修改配置文件

```yml
server:
  port: 8800
spring:
  application:
    name: AaUserService
  datasource:
    # 当前数据源操作类型
    type: com.alibaba.druid.pool.DruidDataSource
    # mysql驱动类
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://rm-2ze5r466gf23tkopqqo.mysql.rds.aliyuncs.com:3306/spring_cloud?useUnicode=true&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=UTC
    username: daniel
    password: Daniel2118
mybatis:
  mapper-locations: classpath*:mapper/*.xml
  type-aliases-package: com.daniel.cloud.user.entity
  # 它一般对应我们的实体类所在的包，这个时候会自动取对应包中不包括包名的简单类名作为包括包名的别名。多个package之间可以用逗号或者分号等来进行分隔（value的值一定要是包的全）

eureka:
  client:
    # 表示自己就是注册中心，不用注册自己
    #    register-with-eureka: false
    # 表示自己就是注册中心，不用去注册中心获取其他服务的地址
    #    fetch-registry: false
    # 注册中心的地址为
    service-url:
      defaultZone: http://eureka9090.com:9090/eureka #将AaUserService注册到9090端口的AxEurekaServer
```

==其中spring,.application.name表示该服务的名称也是注册到Eureka中的名称，注意开启注册服务==

### 在主启动上添加注解

==在主启动类上添加注解==

```java
@SpringBootApplication
@EnableEurekaClient //开启EurekaClient，表示自己是客户端
public class UserApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class, args);
    }
}
```

## 7、注册Order模块

`OrderService（8810）`注册到`AxEurekaServer (9090)`

导入依赖此步骤与`AaUserService（8800）`注册相同此处省略。

## 8、测试

注意==先开启AxEurekaServer（9090）服务，然后开启其它微服务==

输入http://localhost:9090/，出现下面两个名称则说明注册成功。

![image-20220531165803786](image/image-20220531165803786.png)

# 四、Eureka多机环境组建

## 1、修改系统文件

由于只有一台机器，所以可以修改windows系统文件模拟多机环境

![image-20201012183556548](image/image-20201012183556548.png)

修改hosts添加

```
127.0.0.1 eureka9090.com
127.0.0.1 eureka9091.com
```

## 2、创建AyEurekaServer

新建项目==AyEurekaServer(9091)==

### 导入依赖

```XML
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
```

### 修改配置

让两个服务都==互相注册，相互守望==，如果有多个EurekaServer在defaultZone中添加其他的服务地址，多个地址之间用==英文逗号==隔开。

修改9091服务

```yaml
server:
  port: 9091
spring:
  application:
    name: AyEurekaServer
eureka:
  client:
    register-with-eureka: false #表示不向注册中心注册自己
    #    fetch-registry: false #自己就是服务注册中心，不需要去检索服务
    service-url:
      defaultZone: http://localhost:9090/eureka/
```

同时改写9090服务对应的yml

```yaml
server:
  port: 9090
spring:
  application:
    name: eureka9090.com
eureka:
  client:
    service-url:
      defaultZone: http://eureka9091.com:9091/eureka/
```

测试

在地址输入http://eureka9090.com:9090/

![image-20220228101741354](image/image-20220228101741354.png)

在地址输入http://eureka9091.com:9091/

![image-20220228104347749](image/image-20220228104347749.png)

将8800和8810加入到Eureka集群中

修改8800和8810中的yml文件，将其注册到两个server中

```yml
eureka:
  client:
    # 表示自己就是注册中心，不用注册自己
    #    register-with-eureka: false
    # 表示自己就是注册中心，不用去注册中心获取其他服务的地址
    #    fetch-registry: false
    # 注册中心的地址为
    service-url:
#      defaultZone:  http://eureka9090.com:9090/eureka #将AaUserService注册到9090端口的AxEurekaServer
      defaultZone: http://eureka9090.com:9090/eureka/,http://eureka9091.com:9091/eureka/
```

> 注意：记得开启eureka的服务注册，并且`eureka`是集群的话需要相互注册，先启动`9090`和`9091`，然后等`9090`和`9091`启动完毕再启动`8800`和`8810`

# 五、LB负载均衡

## 1、如何多次启动一个项目

我们可以将一个服务多次启动，模拟多实例部署，为了防止端口冲突，需要修改端口

![image-20220531183021027](image/image-20220531183021027.png)

```shell
-Dserver.port=8801
```



## 2、复制User服务

通过`AaUserApplication`复制一个服务`AaUserApplication2 :8801`

添加接口

```java
@GetMapping("/lb")
public String getBalancedServer(HttpServletRequest request){
    String localAddr = request.getLocalAddr();
    int localPort = request.getLocalPort();
    String str = localAddr+":"+localPort;
    return str;
}
```



## 3、修改Order模块

修改`OrderService.java`，将原来的域名端口换成eureka中注册的服务名

```java
@Service
public class OrderService {
    @Autowired
    private OrderMapper orderMapper;

    @Autowired
    private RestTemplate restTemplate;

    public Order queryOrderById(Long orderId) {
        // 1.查询订单
        Order order = orderMapper.findById(orderId);
        // 2.查询用户信息
        // 2.1 请求地址
        String url = "http://AaUserService/user/"+order.getUserId();

        //3.发送请求
        User user = restTemplate.getForObject(url, User.class);
        order.setUser(user);

        // 4.返回
        return order;
    }
}
```

将原来的`RestTemplate`配置单独用配置类配置，并==开启负载均衡，添加注解@LoadBalanced==

```java
@Configuration
public class BeanConfig {
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

为了方便观察，新建接口

```java
@GetMapping("/testBalanced")
public String testBalanced() {
    return orderService.testBalanced();
}
```

orderService中创建方法

```java
public String testBalanced() {
    // 1 请求地址
    String url = "http://AaUserService/user/lb";
    // 2.发送请求
    String str = restTemplate.getForObject(url, String.class);

    return str;
}
```



## 4、测试

测试http://localhost:8810/order/101，发现返回了数据，从控制台我们发现`8800`和`8801`都被访问了

为了直观我们访问http://localhost:8810/order/testBalanced

![image-20220531194305570](image/image-20220531194305570.png)

会发现返回的端口会不断切换



## 5、修改服务主机名和ip在eureka的web上显示

在9001和9003服务中修改yml，添加如语句：

```yaml
eureka:
  instance:
    instance-id: payment9001
    prefer-ip-address: true   #访问路径可以显示ip地址
```

## 6、eureka服务发现

==对于注册进eureka里面的微服务，可以通过服务来发现该服务的信息。==

### controller

以==8800==微服务为例：

```java
//添加discovery
//注意此处导入的是接口
@Autowired
private DiscoveryClient discoveryClient;

@GetMapping(value = "/discovery")
public Object getDiscovery(){
    //        拿到所有注册服务的信息
    List<String> services = discoveryClient.getServices();
    for (String service : services) {
        System.out.println("########element:" +service);
    }
    //        拿到指定服务名称的所有的服务注册信息比如8800模块，它与8801模块的名称都相同
    //        所以这里返回的是list
    List<ServiceInstance> instances = discoveryClient.getInstances("AAUSERSERVICE");
    for (ServiceInstance instance : instances) {
        System.out.println("服务id："+instance.getInstanceId()+
                           "\t服务主机："+instance.getHost()+
                           "\t服务端口："+instance.getPort()+
                           "\t服务Url："+instance.getUri()
                          );
    }
    return this.discoveryClient;
}
```

### 在主启动添加注解

==@EnableDiscoveryClient==

```java
@SpringBootApplication
@EnableEurekaClient //开启EurekaClient，表示自己是客户端
@EnableDiscoveryClient            //添加注解
public class AaUserApplication {
    public static void main(String[] args) {
        SpringApplication.run(AaUserApplication.class, args);
    }
}

```

### 重启8800测试

输入http://localhost:8800/user/discovery

web页面展示

![image-20220601102319725](image/image-20220601102319725.png)

控制台输出：

```java
########element:aborderservice
########element:aauserservice
服务id：Daniel:AaUserService:8801	服务主机：Daniel	服务端口：8801	服务Url：http://Daniel:8801
```

## 7、Eureka自我保护机制

### 自我保护背景

首先对Eureka注册中心需要了解的是Eureka各个节点都是平等的，没有ZK中角色的概念， 即使N-1个节点挂掉也不会影响其他节点的正常运行。

默认情况下，==**如果Eureka Server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，Eureka Server将会移除该实例。**==但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制。

### 自我保护机制

官方对于自我保护机制的定义：

> 自我保护模式正是一种针对网络异常波动的安全保护措施，使用自我保护模式能使Eureka集群更加的健壮、稳定的运行。

自我保护机制的工作机制是：==**如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制**==，此时会出现以下几种情况：

1. Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。
2. Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。
3. 当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。

因此Eureka Server可以很好的应对因网络故障导致部分节点失联的情况，而不会像ZK那样如果有一半不可用的情况会导致整个集群不可用而变成瘫痪。

### 自我保护开关

Eureka自我保护机制，通过配置`eureka.server.enable-self-preservation`来`true`打开/`false`禁用自我保护机制，==默认打开状态==，建议生产环境打开此配置。

### 开发环境配置

开发环境中如果要实现服务失效能自动移除，只需要修改以下配置。

 注册中心关闭自我保护机制，修改检查失效服务的时间。

==关闭eureka-server（9090）的自我保护==

```yaml
server:
  port: 9090
spring:
  application:
    name: AxEurekaServer
eureka:
  instance:
    hostname: eureka9090.com
  client:
    register-with-eureka: false #表示不向注册中心注册自己
    #    fetch-registry: false #自己就是服务注册中心，不需要去检索服务
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
      # 互相守望
#      defaultZone: http://eureka9091.com:9091/eureka/
  server:
    enable-self-preservation: true #禁用自我保护
    eviction-interval-timer-in-ms: 3000 #修改检查失效服务的时间（ms）
```

eureka服务控制台每三秒检查失效服务

微服务修改减短服务心跳的时间

==调整AaUserApplication :8800服务的发送心跳时间间隔及服务端收到心跳等待上限时间==

```yaml
eureka:
  client:
    # 表示自己就是客户端，需要注册到Eureka
    register-with-eureka: true
    # 注册中心获取其他服务的地址
    fetch-registry: true
    # 注册中心的地址为
    service-url:
      defaultZone: http://localhost:9090/eureka #将payment-service注册到9090端口的eureka
#      defaultZone: http://eureka9090.com:9090/eureka/,http://eureka9091.com:9091/eureka/
  instance:
    instance-id: AaUserService${server.port}
    prefer-ip-address: true   #访问路径可以显示ip地址
    lease-renewal-interval-in-seconds: 1    #Eureka向服务端发送心跳的时间间隔，单位是秒（默认是30秒）
    lease-expiration-duration-in-seconds: 2     #Eureka在服务端收到最后一次心跳等待时间的上限，单位为秒（默认是90秒），超时将剔除服务
```

![image-20220601105657272](image/image-20220601105657272.png)

# 六、Ribbon负载均衡

## 1、Ribbon原理

SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。

![image-20210713224517686](image/image-20210713224517686.png)

那么我们发出的请求明明是http://userservice/user/1，怎么变成了http://localhost:8800的呢？

![image-20220601114857466](image/image-20220601114857466.png)

## 2、Ribbon负载均衡策略

Ribbon的负载均衡规则是一个叫做IRule的接口来定义的，每一个子接口都是一种规则：

![负载均衡策略](image/image-20220601115204820.png)

| **内置负载均衡规则类**    | **规则描述**                                                 |
| ------------------------- | ------------------------------------------------------------ |
| RoundRobinRule            | 简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。 |
| AvailabilityFilteringRule | 对以下两种服务器进行忽略： （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。（2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。 |
| WeightedResponseTimeRule  | 为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。 |
| ZoneAvoidanceRule         | 以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。 |
| BestAvailableRule         | 忽略那些短路的服务器，并选择并发数较低的服务器。             |
| RandomRule                | 随机选择一个可用的服务器。                                   |
| RetryRule                 | 重试机制的选择逻辑                                           |

通过定义IRule实现可以修改负载均衡规则，有两种方式：

代码方式：

在orderservice中的`BeanConfig`类中，定义一个新的IRule：

```java
@Bean 
public IRule randomRule(){
    return new RandomRule();
}
```

配置文件方式：

在orderservice的`application.yml`文件中，添加新的配置也可以修改规则：

```yml
AaUserService:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则
```

重启OrderServer，访问http://localhost:8810/order/testBalanced

发现端口并非是各交替一次，而是变为了随机切换

## 3、饥饿加载

Ribbon默认是采用懒加载，即第一次访问时才会去创建`LoadBalanceClient`，请求时间会很长。

而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：

```yml
ribbon:
  eager-load:
    enabled: true # 开启饥饿加载
    clients: # 指定对userservice这个服务饥饿加载，在OrderServer重启时就加载UserService服务列表
      - AaUserService
      
```

重启后，我们可以看到加载了UserService

```java
2022-06-01 14:40:06.188  INFO 13988 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_ABORDERSERVICE/Daniel:AbOrderService:8810 - registration status: 204
2022-06-01 14:40:06.424  INFO 13988 --- [           main] com.daniel.cloud.AbOrderApplication      : Started AbOrderApplication in 3.174 seconds (JVM running for 3.65)
2022-06-01 14:40:06.505  INFO 13988 --- [           main] c.n.u.concurrent.ShutdownEnabledTimer    : Shutdown hook installed for: NFLoadBalancer-PingTimer-AaUserService
2022-06-01 14:40:06.505  INFO 13988 --- [           main] c.netflix.loadbalancer.BaseLoadBalancer  : Client: AaUserService instantiated a LoadBalancer: DynamicServerListLoadBalancer:{NFLoadBalancer:name=AaUserService,current list of Servers=[],Load balancer stats=Zone stats: {},Server stats: []}ServerList:null
2022-06-01 14:40:06.508  INFO 13988 --- [           main] c.n.l.DynamicServerListLoadBalancer      : Using serverListUpdater PollingServerListUpdater
2022-06-01 14:40:06.523  INFO 13988 --- [           main] c.n.l.DynamicServerListLoadBalancer      : DynamicServerListLoadBalancer for client AaUserService initialized: DynamicServerListLoadBalancer:{NFLoadBalancer:name=AaUserService,current list of Servers=[Daniel:8800, Daniel:8801],Load balancer stats=Zone stats: {defaultzone=[Zone:defaultzone;	Instance count:2;	Active connections count: 0;	Circuit breaker tripped count: 0;	Active connections per server: 0.0;]
},Server stats: [[Server:Daniel:8800;	Zone:defaultZone;	Total Requests:0;	Successive connection failure:0;	Total blackout seconds:0;	Last connection made:Thu Jan 01 08:00:00 CST 1970;	First connection made: Thu Jan 01 08:00:00 CST 1970;	Active Connections:0;	total failure count in last (1000) msecs:0;	average resp time:0.0;	90 percentile resp time:0.0;	95 percentile resp time:0.0;	min resp time:0.0;	max resp time:0.0;	stddev resp time:0.0]
, [Server:Daniel:8801;	Zone:defaultZone;	Total Requests:0;	Successive connection failure:0;	Total blackout seconds:0;	Last connection made:Thu Jan 01 08:00:00 CST 1970;	First connection made: Thu Jan 01 08:00:00 CST 1970;	Active Connections:0;	total failure count in last (1000) msecs:0;	average resp time:0.0;	90 percentile resp time:0.0;	95 percentile resp time:0.0;	min resp time:0.0;	max resp time:0.0;	stddev resp time:0.0]
]}ServerList:org.springframework.cloud.netflix.ribbon.eureka.DomainExtractingServerList@4bd52ca4
```



## 4、Ribbon常用负载均衡算法:

**IRule接口,Riboon使用该接口,根据特定算法从所有服务中,选择一个服务,**

**Rule接口有7个实现类,每个实现类代表一个负载均衡算法**

![](image/Ribbon%E7%9A%8414.png)





## 5、轮询的负载均衡算法

### ribbon的轮询算法原理

![](image/Ribbon%E7%9A%8419.png)

![](image/Ribbon%E7%9A%8421.png)


